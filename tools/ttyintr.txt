        *INSTR.  ARGUMENTS                      REMARKS                 SORT

         ORIGIN  20                             TTY HANDLER

TTY_VEC  DW      TTY_INTR,0

         ORIGIN  62                             USER SAVE

USR_SAVE DW      START,0740000000000

         ORIGIN  1024

IPL      LCTL    1,.CW
         RLMSK   .MASK

CW       DW      0036000000000                  RETURN TO IRQL 15
MASK     DW      02000                          ENABLE CONSOLE IRQ
TTY_STAT DW      0

TTY_INTR NIOC    48                             CLEAR INTR
         ST      0,.TTY_ACSV
         LX      0,1                            CONSOLE HAS DATA
         ST      0,.TTY_STAT
         L       0,.TTY_ACSV
         RFI     0

TTY_ACSV DW      0

DEADBEEF DW      3735928559

CRLF     DW      2
         ASCII   \015\012

        ****************************************************************

START    LX      13,STACK

         RIO     48,0,1                         Enable keyboard
         AX      0,256
         WIO     48,0,1

         AX      13,-35
         
         LA      13,3
         L       4,.DEADBEEF
         LX      5,16
         BSM     .NUM2LD

         LA      13,3
         AX      13,-3
         LX      8
         ST      0(13)
         LA      13,4
         LX      5,48
         BSM     .LEFT_PAD

         LA      13,3
         BSM     .WRITELD
         LX      3,.CRLF
         BSM     .WRITELD

         AX      13,3

LOOP     LA      13,3
         LX      4,170
         BSM     .READLD
         
         SA      0,0,I(2),NL,TRZ
         B       .DIE
         
         LA      13,3
         BSM     .WRITELD
         
         B       .LOOP

DIE      AX      13,35

         RIO     48,0,1                         Disable keyboard
         AX      0,-256
         WIO     48,0,1
         
         LCTL    1,.HALT
         LMSK    .HALT
         HLT

HALT     DW      0

        ****************************************************************
        * Fastcall: X0-X3 for first args, caller saved
        *

        ****************************************************************
        * LEFT_PAD - you already know
        *
        *       X0 -> input buffer address
        *       X1 -> output buffer address, must specify length
        *       X2 -> padding character
        *
        *       Return -1 on failure, 0 on success
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

LEFT_PAD DW      0

         L       0(4)                           Abort if input too big
         S       0(3)
         TACBN   1
         BRM

         TACZ                                   Copy now if no padding
         B       .CPYINPUT

         NA      0,0

WRITEPAD ISTC    5,4,7
         IA      0,0,TRN
         B       .WRITEPAD

CPYINPUT LN      0(3)                           Done if input length 0
         TACZ
         BRM

CPYILOOP ILC     5,3,7
         ISTC    5,4,7
         IA      0,0,TRN
         B       .CPYILOOP

         XA      0,0
         BRM

COPYFAIL SMAC    36
         BRM

        ****************************************************************
        * NUM2LD - convert number to string
        *
        *       X0 -> buffer address
        *       X1 -> value
        *       X2 -> base
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

NUM2LD   USING   1,2

         ST      5,1-                           Set up divisor at 5
         LA      13,5

         XA      0,0                            Initialize string
         ST      0,0(3)

         LA      4,0

DIV      D       0(5)                           Grab digit and remainder
         ST      2,1-                           Push digit
         ITN     0(3)                           Increment string size
         LA      1,0,TRN                        Test if done
         B       .DIV                           Loop until zero

         LA      3,5
         LX      1,58

CONVERT  L       4,1+                           Pop digits into string
         AA      4,4,I(48)
         TRGE    4,1
         AA      4,4,I(7)
         ISTC    4,3,7
         ITNE    0,0(5)
         B       .CONVERT

         IA      13,13
         BRM

        ****************************************************************
        * READLD - read up to n characters from the support console
        *
        *       X0 -> buffer address
        *       X1 -> max chars
        *
        *       Returns length of input
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

READLD   USING   7,8

         LA      3,7                            7: buffer
         XA      0,0                            Clear count field
         ST      0,0(7)
         TRZ     7                              Don't read if count 0
         BRM
         NA      4,8                            8: max length
         
         ST      7,1-                           Push head of string
         
         B       .READLOOP

IDLELOOP LX      3,.TEST_RST
         LX      4,.TTY_STAT                    Wait for full buffer
         BSM     .IDLE                          or crlf

READLOOP RIO     48,0,2                         Get buffer count
         LA      0,0,NL,CC,M(28),TRZ
         B       .IDLELOOP                      Idle if no data
         
         ITN     @0(13)                         Increment length
         RIO     48,0,0                         Get a byte
         ISTC    0,7,7                          Save

         IA      8,8,TRN                        Is buffer full?
         SA      0,0,NL,I(10),TRZ               Or did we get LF?
         B       .READDONE

         B       .READLOOP

READDONE L       0,@1+                          Return length
         BRM

        ****************************************************************
        * WRITELD - write a length-data string to the support console
        *
        *       X0 -> buffer address
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

WRITELD  DW      0

         LN      4,0(3)
         TRZ     4
         BRM

WRT_LOOP TIOBZ   48
         B       .WRT_LOOP

         ILC     0,3,7
         WIOS    48,0,0
         
         IA      4,4,TRN
         B       .WRT_LOOP
         
         BRM

        ****************************************************************
        * IDLE - wait until we have something to do
        *
        *      X0 -> test subroutine
        *      X1, X2, X3 -> arguments to subroutine (optional, will not
        *                    be modified by IDLE)
        *      Return -> whatever the subroutine puts in AC
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

IDLE     USING   12

         STMSK   1-                             Save interrupt mask

DOIDLE   LMSK    .MASKALL                       Mask all interrupts

         BL      0(3)                           Idle test callback
         TACN
         B       .DONTIDLE

         MWAIT   0(13)                          Wait for interrupts
         B       .DOIDLE

DONTIDLE LMSK    1+                             Restore mask
         BRM

MASKALL  DW      0

        ****************************************************************
        * TEST_RST - if (X1) != 0 then AC := (X1), (X1) := 0; return AC
        *
        *INSTR.  ARGUMENTS                      REMARKS                 SORT

TEST_RST L       0,0(4)
         TACZ
         B       .DONT_RST

         ST      2,1-
         XA      2,2
         ST      2,0(4)
         L       2,1+

DONT_RST B       0(12)

        ****************************************************************

         ORIGIN  2048

STACK    BSS     0
